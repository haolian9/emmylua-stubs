---@class vim.lsp.LangserInitParams
---@field processId number
---@field clientInfo {name: "Neovim", version: string}
---@field rootUri? string
---@field workspaceFolders? string[]
---@field initializationOptions any
---@field capabilities table
---@field trace "off"|"messages"|"verbose"
vim.lsp.LangserInitParams = {}

---see vim.lsp.start() and vim.lsp.start_client()
---mandatory properties: name, cmd, root_dir
---@class vim.lsp.LangserSpec
---
---arbitrary name for the LSP client. Should be unique per language server.
---default=client-id
---@field name? string
---
---command string or list treated like |jobstart()|.
---The command must launch the language server process. `cmd` can also be a function that creates an RPC client.
---The function receives a dispatchers table and must return a table with the functions `request`, `notify`, `is_closing` and `terminate`
---See |vim.lsp.rpc.request()| and |vim.lsp.rpc.notify()| For TCP there is a built-in rpc client factory: |vim.lsp.rpc.connect()|
---@field cmd string|string[]|fun(dispatchers: table):string[]
---
---Directory to launch the `cmd` process. Not related to `root_dir`.
---default=getcwd()
---@field cmd_cwd? string
---
---Environment flags to pass to the LSP on spawn. Must be specified using a map-like table. Non-string values are coerced to string.
---@field cmd_env? {[string]: number|string}
---
---Daemonize the server process so that it runs in a separate process group from Nvim.
---Nvim will shutdown the process on exit, but if Nvim fails to exit cleanly this could leave behind orphaned server processes.
---default true
---@field detached? boolean
---
---List of workspace folders passed to the language server.
---For backwards compatibility rootUri and rootPath will be derived from the first workspace folder in this list.
---See `workspaceFolders` in the LSP spec.
---@field workspace_folders? {uri: string, name: string}[]
---
---Map overriding the default capabilities defined by |vim.lsp.protocol.make_client_capabilities()|, passed to the language server on initialization.
---Hint: use make_client_capabilities() and modify its result.
---Note: To send an empty dictionary use `{[vim.type_idx]=vim.types.dictionary}`, else it will be encoded as an array.
---@field capabilities? {[string]: any}
---
---Map of language server method names to |lsp-handler|
---@field handlers? {[string]: any}
---
---Map with language server specific settings.
---These are returned to the language server if requested via `workspace/configuration`. Keys are case-sensitive.
---@field settings? table
---
---Values to pass in the initialization request as `initializationOptions`.
---See `initialize` in the LSP spec.
---@field init_options any
---
---Defaults to the filetype.
---@field get_language_id? fun(bufnr: number, filetype: string): string
---
---the encoding that the LSP server expects. Client does not verify this is correct.
---default="utf-16"
---@field offset_encoding? "utf-8"|"utf-16"|"utf-32"
---
---invoked when the client operation throws an error. `code` is a number describing the error. Other arguments may be passed depending on the error kind.
---See `vim.lsp.rpc.client_errors` for possible errors.
---Use `vim.lsp.rpc.client_errors[code]` to get human-friendly name.
---@field on_error? fun(code: number, ...)
---
---invoked before the LSP "initialize" phase, where `params` contains the parameters being sent to the server and `config` is the config that was passed to |vim.lsp.start_client()|.
---You can use this to modify parameters before they are sent.
---@field before_init? fun(init_params: vim.lsp.LangserInitParams, start_client_config: LangserSpec)
---
---invoked after LSP "initialize", where `result` is a table of `capabilities` and anything else the server may send.
---For example, clangd sends `initialize_result.offsetEncoding` if `capabilities.offsetEncoding` was sent to it.
---You can only modify the `client.offset_encoding` here before any notifications are sent.
---Most language servers expect to be sent client specified settings after initialization. Neovim does not make this assumption.
---A `workspace/didChangeConfiguration` notification should be sent to the server during on_init.
---@field on_init? fun(client, init_result: any)
---
---invoked on client exit.
---@field on_exit? fun(exit_code: number, signal: number, client_id: number)
---
---invoked when client attaches to a buffer.
---@field on_attach fun(client, bufnr: number)
---
---passed directly to the language server in the initialize request.
---Invalid/empty values will default to "off"
---@field trace? "off"|"message"|"verbose"
---
---A table with flags for the client. The current (experimental) flags are:
---* allow_incremental_sync (bool, default true): Allow using
---  incremental sync for buffer edits
---* debounce_text_changes (number, default 150): Debounce
---  didChange notifications to the server by the given
---  number in milliseconds. No debounce occurs if nil
---* exit_timeout (number|boolean, default false):
---  Milliseconds to wait for server to exit cleanly after
---  sending the "shutdown" request before sending kill -15.
---  If set to false, nvim exits immediately after sending
---  the "shutdown" request to the server.
---@field flags? {allow_incremental_sync: boolean?, debounce_text_changes: number?, exit_timeout: number|boolean|nil}
---
---path to the project root. By default this is used to decide if an existing client should be re-used.
---Directory where the LSP server will base its workspaceFolders, rootUri, and rootPath on initialization.
---@field root_dir? string
vim.lsp.LangserSpec = {}

---@alias vim.lsp.Handler fun(err?: any, result?: any, ctx: {method: string, client_id: integer, bufnr: integer, params?: table}, config: table): any?, {code: integer, message: any, data?: any}}?
